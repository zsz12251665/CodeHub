# HDU 1686

## 描述

- [Virtual Judge](https://vjudge.net/problem/HDU-1686)
- [HDU](http://acm.hdu.edu.cn/showproblem.php?pid=1686)

## 解法

本题是 <abbr title="Knuth-Morris-Pratt 算法">KMP</abbr> 的一道练习题。

众所周知，一种简单的在匹配串中找模式串的方法就是枚举模式串的起始位置，也就是与模式串第一个字符相匹配的字符位置。然后顺着模式串扫一遍，检查是否每一个字符都匹配。因此时间复杂度为 $\operatorname{O}(n m)$，其中 $n$ 和 $m$ 分别代表匹配串和模式串的长度。然而，你会发现有些字符没有必要比较多次。比如，对于一个形如 `"ABCA"` 的模式串，如果你在第最后一位发现不匹配，你没必要只把模式串向前移1位，应该直接移4位，因为无论是移1位、2位还是3位，匹配一定不成功。这就是 KMP 的机制。

KMP 基于这样一条简单的规律：当你的指针扫到某一位时，你已经知道了所有在其之前出现的字符。如果我们能妥善地利用这些信息，我们就无须把指针往回移。这就是 KMP 高效的秘诀。做到这一点的办法就是部分匹配值表（下文会详细介绍）。当我们找到一个不匹配的字符时，模式串向前移动的量即为当前已匹配的字符数与其部分匹配值之差。

一个字符串的部分匹配值为其相等真前缀与真后缀的最大长度。举个例子 `"ABCABC"` 的部分匹配值为3，因为 `"ABC"` 既是其前缀又是其后缀。一个字符串的部分匹配值表为其所有前缀的部分匹配值组成的的表。在下面的样例中，$w$ 为模式串，$v$ 为其部分匹配值。

|  $w$  |  `A`  |  `A`  |  `B`  |  `D`  |  `A`  |  `A`  |  `B`  |  `C`  |  `A`  |  `A`  |  `A`  |  `B`  |  `D`  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  $v$  |  $0$  |  $1$  |  $0$  |  $0$  |  $1$  |  $2$  |  $3$  |  $0$  |  $1$  |  $2$  |  $2$  |  $3$  |  $4$  |

## 代码

- [正解](HDU.1686.0.cpp)
