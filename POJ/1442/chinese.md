# POJ 1442

## 描述

- [Virtual Judge](https://vjudge.net/problem/POJ-1442)
- [POJ](http://poj.org/problem?id=1442)

## 解法

这道题需要两个堆，一个小根堆和一个大根堆。我们按照下列方法来处理：当我们已处理 $j$ 个 GET 请求时，我们将最小的 $j$ 个数存在大根堆里。当处理 ADD 请求时，我们就能通过与堆顶比较，以确定新的数是否会是最小的 $j$ 个数之一。如果是，则将弹出堆顶，按入新的数，并将旧堆顶放入小根堆中。否则直接将新的数压入小根堆即可。这样第 $(j+1)$ 小的数会是小根堆的堆顶。因此我们只用 $\operatorname{O}(\log{n})$ 即可处理一个 ADD 请求。当处理 GET 请求时，我们只用把小根堆的堆顶移到大根堆中。这也可以在 $\operatorname{O}(\log{n})$ 内完成。因此总的时间复杂度就是 $\operatorname{O}(n\log{n})$。

同时，本题解还会向您介绍如何实现一个堆。堆是一棵完全二叉树，它除根节点外的所有节点都比其父节点更小（或者更大）。这也就是小根堆和大根堆的区别。如果每个节点小于其父节点，则根节点就是最小的节点。这就称作小根堆。类似的，我们有大根堆。接下来我们以小根堆为例。当一个新的元素加入堆中时，它被放在树的最后并与其父节点比较。如果父节点比子节点大，则交换他们并继续比较，直到父节点小于子节点。这个过程称为<abbr title="shift up">上移</abbr>。堆总共有 $\lceil\log_2n\rceil$ 层，因此插入是 $\operatorname{O}(\log{n})$ 的。当我们需要移除堆顶元素时，我们可以用堆中最后一个元素取代之。然后我们将其与其最小的子节点比较。如果父节点较大，则交换之并继续，否则停止。这个过程称为<abbr title="shift down">下移</abbr>。移除堆顶的时间复杂度也与层数成正比，因此它也是 $\operatorname{O}(\log{n})$ 的。所以，通过一个堆，你可以在 $\operatorname{O}(\log{n})$ 插入一个元素或删除最小元素，并在 $\operatorname{O}(1)$ 内取得最小元素。

## 代码

- [正解](POJ.1442.0.cpp)
