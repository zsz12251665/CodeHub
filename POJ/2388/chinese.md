# POJ 2388

## 描述

- [Virtual Judge](https://vjudge.net/problem/POJ-2388)
- [POJ](http://poj.org/problem?id=2388)

## 解法

本题对数组排序并输出中间值即可。以下是几种流行的排序算法。

[冒泡排序](POJ.2388.0.cpp)：这是一种 $\operatorname{O}(n^2)$ 的算法。根据算法，你需要扫描整个数组 $n$ 次，比较相邻元素并把较大的放在后方。每次扫描时，你会发现最大的元素被放到了最后，就像一个个泡泡浮上来一样。

[选择排序](POJ.2388.1.cpp)：这是冒泡排序的一种优化版本，将交换次数从 $\operatorname{O}(n^2)$ 降到了 $\operatorname{O}(n)$。由于每次扫描时我们都要将最大元素放到最后，为什么不直接找到它并将它换到最后呢（或是像我的代码那样，找到最小的并把它放到最前面）？我们扫描剩余的部分，记录最大元素的下标，并将其换到最后。每次扫描只有一次交换，使得交换次数仅有 $\operatorname{O}(n)$。

[插入排序](POJ.2388.2.cpp)：这也是一种 $\operatorname{O}(n^2)$ 的算法。其排序数组的方式与排序扑克牌的方式类似。每次拿起一张牌，然后插入手牌中的合适位置。插入排序和冒泡排序的算法都很简单，但是效率不高。

[快速排序](POJ.2388.3.cpp)：这是一种 $\operatorname{O}(n\log{n})$ 的算法。它非常高效，但是最坏情况下，它需要做 $\operatorname{O}(n^2)$ 次比较（尽管这种情况并不常见）。快速排序是一种分治的算法。首先你把数组按照大小分成两半。然后在对这两个子数组排序，直到其大小为0或1。

[归并排序](POJ.2388.4.cpp)：这也是一种 $\operatorname{O}(n\log{n})$ 的算法。快速排序与归并排序最大的不同在于归并排序在时间和顺序上都是稳定的，然而快速排序不是。它也是一种分治的算法。首先将数组平分，直至其大小为0或1，然后将这两个有序的子数组通过每次选较小的首个元素合并在一起。

[堆排序](POJ.2388.5.cpp)：堆排序正如其名，是一种使用堆这个数据结构来进行排序的算法。众所周知，堆可以在 $\operatorname{O}(\log{n})$ 内插入一个元素或弹出最小元素（实际上，如果在数组中初始化堆，初始化整体时间复杂度仅为 $\operatorname{O}(n)$）。因此其总复杂度为 $\operatorname{O}(n\log{n})$。

[计数排序](POJ.2388.6.cpp)：计数排序是一种用来排序小范围数据的算法。其时间复杂度为 $\operatorname{O}(n+k)$（$k$ 为数据范围）。你需要另一个数组 $c$。然后在 $\operatorname{O}(n)$ 的时间内扫描数据数组并统计数据范围内每个整数出现的次数。最后再扫描数组 $c$ 并输出排序好的数据。

## 代码

- [冒泡排序](POJ.2388.0.cpp)
- [选择排序](POJ.2388.1.cpp)
- [插入排序](POJ.2388.2.cpp)
- [快速排序](POJ.2388.3.cpp)
- [归并排序](POJ.2388.4.cpp)
- [堆排序](POJ.2388.5.cpp)
- [计数排序](POJ.2388.6.cpp)
