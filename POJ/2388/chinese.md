# POJ 2388

## 描述

- [Virtual Judge](https://vjudge.net/problem/POJ-2388)
- [POJ](http://poj.org/problem?id=2388)

## 解法

本题对数组排序并输出中间值即可。以下是几种流行的排序算法。

[插入排序](POJ.2388.0.cpp)：这是一种 $\operatorname{O}(n^2)$ 的算法。其排序数组的方式与排序扑克牌的方式类似。每次拿起一张牌，然后插入手牌中的合适位置。插入排序和冒泡排序的算法都很简单，但是效率不高。

[冒泡排序](POJ.2388.1.cpp)：这也是一种 $\operatorname{O}(n^2)$ 的算法。你需要扫描整个数组 $n$ 次。每次扫描时，找到最大的元素并把它放到最后，就像一个个泡泡浮上来一样。

[快速排序](POJ.2388.2.cpp)：这是一种 $\operatorname{O}(n\log{n})$ 的算法。它非常高效，但是最坏情况下，它需要做 $\operatorname{O}(n^2)$ 次比较（尽管这种情况并不常见）。快速排序是一种分治的算法。首先你把数组按照大小分成两半。然后在对这两个子数组排序，直到其大小为0或1。

[归并排序](POJ.2388.3.cpp)：这也是一种 $\operatorname{O}(n\log{n})$ 的算法。快速排序与归并排序最大的不同在于归并排序在时间和顺序上都是稳定的，然而快速排序不是。它也是一种分治的算法。首先将数组平分，直至其大小为0或1，然后将这两个有序的子数组通过每次选较小的首个元素合并在一起。

[堆排序](POJ.2388.4.cpp)：堆排序正如其名，是一种使用堆这个数据结构来进行排序的算法。众所周知，堆可以在 $\operatorname{O}(\log{n})$ 内插入一个元素或弹出最小元素。因此其总复杂度为 $\operatorname{O}(n\log{n})$。

[计数排序](POJ.2388.5.cpp)：计数排序是一种用来排序小范围数据的算法。其时间复杂度为 $\operatorname{O}(n+k)$（$k$ 为数据范围）。你需要另一个数组 $c$。然后在 $\operatorname{O}(n)$ 的时间内扫描数据数组并统计数据范围内每个整数出现的次数。最后再扫描数组 $c$ 并输出排序好的数据。

## 代码

- [插入排序](POJ.2388.0.cpp)
- [冒泡排序](POJ.2388.1.cpp)
- [快速排序](POJ.2388.2.cpp)
- [归并排序](POJ.2388.3.cpp)
- [堆排序](POJ.2388.4.cpp)
- [计数排序](POJ.2388.5.cpp)
